import string
import pandas as pd
import unicodedata
import re
import time
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.neighbors import NearestNeighbors
import Levenshtein
from nltk.metrics import jaccard_distance

class DataCleaner:
    @staticmethod
    def remove_accents(input_str):
        nfkd_form = unicodedata.normalize('NFD', input_str)
        return ''.join([c for c in nfkd_form if not unicodedata.combining(c)])
    
    @staticmethod
    def cleantext(text):
        if pd.isnull(text): 
            return ""
        text = str(text).lower()
        text = text.translate(str.maketrans('', '', string.punctuation))
        text = ' '.join(text.split())
        text = DataCleaner.remove_accents(text)
        text = re.sub(r'(.)\1+', r'\1', text)
        vowels = "aeiouy"
        return ''.join(char for char in text if char not in vowels)
    
    @staticmethod
    def cleannum(num):
        if pd.isnull(num): 
            return ""
        return re.sub(r'[\s\-\.]', '', str(num))

class RecordComparator:
    @staticmethod
    def compnumcin(r1, r2):
        score = 0
        if r1["CIN_BENEF"] and r2["CIN_BENEF"]:
            if r1["CIN_BENEF"] == r2["CIN_BENEF"]:
                score += 4
            elif Levenshtein.distance(r1["CIN_BENEF"], r2["CIN_BENEF"]) <= 2:
                score += 2
            else:
                score -= 3
        if r1["TEL_BENEF"] and r2["TEL_BENEF"]:
            if r1["TEL_BENEF"] == r2["TEL_BENEF"]:
                score += 3
            elif Levenshtein.distance(r1["TEL_BENEF"], r2["TEL_BENEF"]) <= 2:
                score += 2
            else:
                score -= 3
        return 10 if score == 7 else score
    
    @staticmethod
    def compfnamelname(r1, r2):
        score = 0
        for k in ["PREN_BENEF", "NOM_PREN_BENEF"]:
            if r1[k] and r2[k]:
                if r1[k] == r2[k]:
                    score += 2
                elif Levenshtein.distance(r1[k], r2[k]) <= 2:
                    score += 1
                else:
                    score -= 2
        return 5 if score == 4 else score
    
    @staticmethod
    def compmomdad(r1, r2):
        score = 0
        for k in ["PREN_PERE_BENEF", "PREN_MERE_BENEF"]:
            if r1[k] and r2[k]:
                if r1[k] == r2[k]:
                    score += 2
                elif Levenshtein.distance(r1[k], r2[k]) <= 2:
                    score += 1
                else:
                    score -= 2
        return score
    
    @staticmethod
    def compaddress(r1, r2):
        if not r1["ADR_BENEF"] or not r2["ADR_BENEF"]:
            dist = 1.0
        else:
            set1 = set(r1["ADR_BENEF"].split())
            set2 = set(r2["ADR_BENEF"].split())
            dist = jaccard_distance(set1, set2)
        score = 2 if dist <= 0.3 else 1 if dist < 0.5 else -1
        if r1["SEXE_BENEF"] == r2["SEXE_BENEF"] and r1["DATE_NAI_BENEF"] == r2["DATE_NAI_BENEF"]:
            score += 1
        return score
    
    @classmethod
    def calculate_score(cls, r1, r2):
        score = cls.compfnamelname(r1, r2) + cls.compnumcin(r1, r2)
        if score <= 0:
            return score
        return score + cls.compmomdad(r1, r2) + cls.compaddress(r1, r2)

def load_and_clean_data(filepath):
    cols = ["COD_BENEF", "NOM_PREN_BENEF", "DATE_NAI_BENEF", "SEXE_BENEF", 
            "ADR_BENEF", "CIN_BENEF", "TEL_BENEF", "PREN_PERE_BENEF", 
            "PREN_MERE_BENEF", "PREN_BENEF"]
    
    df = pd.read_csv(filepath, sep=";", encoding="cp1256", usecols=cols, nrows=60000)
    
    for col in cols:
        if col in ["CIN_BENEF", "TEL_BENEF", "DATE_NAI_BENEF"]:
            df[col] = df[col].apply(DataCleaner.cleannum)
        elif col != "COD_BENEF":
            df[col] = df[col].apply(DataCleaner.cleantext)
    
    df["COMPOSITE"] = (
        df["NOM_PREN_BENEF"].fillna("") + " " +
        df["PREN_BENEF"].fillna("") + " " +
        df["PREN_PERE_BENEF"].fillna("") + " " +
        df["PREN_MERE_BENEF"].fillna("") + " " +
        df["ADR_BENEF"].fillna("")
    )
    
    return df, df.to_dict(orient="records")

def find_matches(row_dicts, vectorizer, min_score=6):
    X = vectorizer.fit_transform([r["COMPOSITE"] for r in row_dicts])
    neigh = NearestNeighbors(n_neighbors=15, metric="cosine", n_jobs=-1)
    neigh.fit(X)
    distances, indices = neigh.kneighbors(X)
    
    all_results = []
    for i, neighbors in enumerate(indices):
        cod_i = row_dicts[i]["COD_BENEF"]
        for j in neighbors:
            if j <= i:
                continue
            score = RecordComparator.calculate_score(row_dicts[i], row_dicts[j])
            if score >= min_score:
                all_results.append({
                    "COD_BENEF": cod_i,
                    "MATCHED_COD_BENEF": row_dicts[j]["COD_BENEF"],
                    "SCORE": score
                })
    return all_results

def main():
    start = time.time()
    
    # Load and clean data
    df, row_dicts = load_and_clean_data("/content/patient(1).csv")
    
    # Initialize vectorizer
    vectorizer = TfidfVectorizer(analyzer='char_wb', ngram_range=(2, 5), max_features=3000)
    
    # Find matches
    all_results = find_matches(row_dicts, vectorizer, min_score=6)
    
    # Save results
    results_df = pd.DataFrame(all_results)
    results_df = results_df.sort_values("SCORE", ascending=False)
    results_df = results_df.drop_duplicates(subset=["COD_BENEF", "MATCHED_COD_BENEF"])
    results_df.to_excel("/content/matching_results.xlsx", index=False)
    
    print(f"Found {len(results_df)} matches with score >= 6")
    print(f"Finished in {time.time() - start:.2f} seconds")

if __name__ == "__main__":
    main()
